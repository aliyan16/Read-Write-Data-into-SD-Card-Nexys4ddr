SD Reader/Writer + AES (Current Code)
====================================

Project status
--------------
This project uses SPI-mode SD access on Nexys4 DDR with:
- Manual write/read actions
- Separate encrypt/decrypt/delete actions
- FAT16 DATA.BIN area addressing (base sector offset 20)

Top-level module: top.v
SD controller: sd_spi.v
Display: sevenSeg.v
Constraints: nexys4ddr.xdc

Controls
--------
Switches:
- SW0:
  - 1 = Write mode for BTNC
  - 0 = Read mode for BTNC
- SW4_1 = input digit nibble (typically 0-9)
- SW15_5 = DATA.BIN block index (0..2047)

Buttons:
- BTNC:
  - If SW0=1: write selected digit at selected block
  - If SW0=0: read selected block and show first nibble
- BTNU: encrypt selected block and store at next block
- BTNR: decrypt selected block and store at next block
- BTNL: delete selected block (write zeros)
- BTND: reset

Address mapping
---------------
Physical SD sector = 20 + SW15_5
- SW15_5=0 -> sector 20
- SW15_5=1 -> sector 21
- SW15_5=2 -> sector 22

For encrypt/decrypt actions:
- Source = selected SW15_5
- Destination = selected SW15_5 + 1 (clamped at 2047)

Data layout per sector
----------------------
Each operation writes a full 512-byte sector.
Current write path uses:
- First 16 bytes from 128-bit block payload
- Remaining bytes are 00

Examples:
- Write digit 2 at SW15_5=0:
  - Block 0 starts with: 32 32 00 00 ...
- Encrypt SW15_5=0:
  - Encrypted bytes written into block 1 first 16 bytes
- Decrypt SW15_5=1:
  - Decrypted bytes written into block 2 first 16 bytes

LED mapping (current)
---------------------
- LED[0]  = init_done
- LED[1]  = write done
- LED[2]  = encrypt done
- LED[3]  = decrypt done
- LED[4]  = delete done
- LED[5]  = read done
- LED[6]  = busy
- LED[15] = init error

7-segment behavior
------------------
- Shows low nibble of latest displayed value
- Supports 0..F display (hex)

Important note about AES decryption
----------------------------------
With the current AES sources in Aes-Code, encryption flow works and writes ciphertext,
but decrypt output is not currently matching the original plaintext in end-to-end tests.
So LED[3] indicates decrypt operation completed, not that plaintext equality is guaranteed.

Verification
------------
Use verify_sd.py as Administrator:

python verify_sd.py \\.\PhysicalDrive1 <base_block>

Example:
python verify_sd.py \\.\PhysicalDrive1 0

This prints first 16 bytes of:
- base block
- base+1 block
- base+2 block
and shows a quick comparison of base vs base+2.

Button pin constraints (Nexys4 DDR)
-----------------------------------
- BTNC: N17
- BTNU: M18
- BTNR: M17
- BTNL: P17
- BTND: P18
