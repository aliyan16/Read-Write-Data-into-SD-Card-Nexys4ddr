================================================================
  FPGA SD CARD READ/WRITE SYSTEM — HOW IT WORKS
  Nexys4 DDR (Artix-7) | SPI Mode | FAT16 Filesystem
================================================================


━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
1. OVERALL APPROACH
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

The system has 3 layers:

  [FPGA Switches/Buttons]
        |
        v
  [top.v — Control Logic]   ← decides what address to access
        |
        v
  [sd_spi.v — SPI Driver]   ← talks to SD card over 4 wires
        |
        v
  [SD Card — FAT16 Volume]  ← stores data in DATA.BIN file


━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
2. SD CARD PHYSICAL LAYOUT
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

The SD card is divided into 512-byte blocks (sectors).
format_sd.py wrote this structure once to the SD card:

  Sector 0         = Boot Sector (BPB)
                     Tells the OS: "this is a FAT16 volume,
                     1MB total, one file DATA.BIN"

  Sectors 1-9      = FAT Table (copy 1)
                     A chain map: cluster 2→3, 3→4, ..., 2049→END
                     This tells Windows that DATA.BIN occupies
                     2048 consecutive clusters (sectors 20-2067)

  Sectors 10-18    = FAT Table (copy 2)
                     Identical backup of FAT table (FAT spec requires 2)

  Sector 19        = Root Directory
                     One 32-byte entry:
                       Name      = "DATA    BIN"
                       Size      = 1,048,576 bytes (1 MB)
                       1st clust = 2
                       Attribute = 0x20 (Archive)

  Sectors 20-2067  = DATA.BIN data area  ← FPGA reads/writes HERE
                     2048 sectors × 512 bytes = 1,048,576 bytes = 1 MB
                     This is the actual file content.


━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
3. ADDRESS MAPPING (How switches map to SD sectors)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

In top.v:
  wire [31:0] addr = 32'd20 + {21'b0, SW15_5};

  SW[15:5] is an 11-bit number (0 to 2047).
  Adding 20 skips the FAT16 metadata sectors.
  Result: addr points directly into DATA.BIN's sectors.

  Examples:
    SW[15:5] = 0    →  SD sector 20  →  DATA.BIN byte offset 0
    SW[15:5] = 1    →  SD sector 21  →  DATA.BIN byte offset 512
    SW[15:5] = 2    →  SD sector 22  →  DATA.BIN byte offset 1024
    SW[15:5] = 100  →  SD sector 120 →  DATA.BIN byte offset 51200
    SW[15:5] = 2047 →  SD sector 2067→  DATA.BIN byte offset 1,047,552

  The FPGA sends this 32-bit block address directly to CMD24/CMD17.
  For SDHC cards: address = block number (not byte address).


━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
4. SPI COMMUNICATION PROTOCOL
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

SPI (Serial Peripheral Interface) uses 4 wires:

  SD_CMD  (MOSI)  ─── FPGA sends data TO SD card
  SD_DAT0 (MISO)  ─── FPGA receives data FROM SD card
  SD_SCK          ─── Clock (250 kHz, generated by FPGA)
  SD_DAT3 (CS)    ─── Chip Select, active LOW

SPI Mode 0 (CPOL=0, CPHA=0):
  - Data sampled on RISING edge of clock
  - Data shifted on FALLING edge of clock
  - MSB sent first

All SD commands are 6 bytes: [CMD | ARG(4 bytes) | CRC]


━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
5. SD CARD INITIALIZATION (auto on power-up)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

When FPGA powers up, sd_spi.v runs this sequence automatically:

  Step 1: SD_RESET = HIGH (power OFF) for 1ms
  Step 2: SD_RESET = LOW  (power ON), wait 250ms for card to stabilise
  Step 3: Send 80 dummy clock pulses (CS=HIGH)
           → Puts card into SPI mode
  Step 4: CMD0 (GO_IDLE)
           → Resets card, expects response 0x01 (idle)
  Step 5: CMD8 (SEND_IF_COND)
           → Checks voltage compatibility (3.3V)
           → Required for SDHC cards
  Step 6: CMD55 + ACMD41 (with HCS=1)
           → Initializes the card
           → HCS=1 means "I support High Capacity (SDHC)"
           → Repeated until card responds 0x00 (ready)
  Step 7: LED[0] = ON  →  Initialization complete!

  If any step fails → LED[15] = ON (error)


━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
6. WRITE OPERATION  (SW0=1, press BTNC)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

User action:
  Set SW0=1, set digit on SW[4:1], set address on SW[15:5], press BTNC

What happens in top.v:
  1. wr_byte  <= {4'h3, SW4_1}    e.g. digit 5 → 0x35 (ASCII '5')
  2. addr     = 32'd20 + SW15_5   e.g. SW15_5=3 → addr=23
  3. wr_start = 1 (pulse)         → triggers sd_spi.v

What happens in sd_spi.v (CMD24 sequence):
  1. CS = LOW (select card)
  2. Send 6-byte CMD24 command:
       [0x58][addr[31:24]][addr[23:16]][addr[15:8]][addr[7:0]][0xFF]
       0x58 = CMD24 opcode (WRITE SINGLE BLOCK)
  3. Wait for R1 response (0x00 or 0x01 = OK)
  4. Send data start token: 0xFE
  5. Send 512 bytes of data:
       ALL 512 bytes = wr_byte (same byte repeated)
       e.g. all = 0x35 for digit 5
  6. Send 2 CRC bytes: 0xFF 0xFF (dummy, CRC disabled in SPI mode)
  7. Wait for data response token from card
       Lower 5 bits = 0x05 means "Data Accepted"
  8. Wait for card to finish internal flash write
       Card holds MISO LOW while writing (can take up to 250ms)
       Card releases MISO HIGH when done
  9. CS = HIGH, wr_done = 1

back in top.v:
  10. write_led <= 1  →  LED[1] turns ON

Result on SD card (e.g. digit 5 at address 3):
  Sector 23 of SD card = DATA.BIN byte offset 1536:
  [35 35 35 35 35 35 35 35 ... 35]  (512 bytes, all 0x35)


━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
7. READ OPERATION  (SW0=0, press BTNC)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

User action:
  Set SW0=0, set address on SW[15:5], press BTNC

What happens in top.v:
  1. addr     = 32'd20 + SW15_5
  2. rd_start = 1 (pulse)  → triggers sd_spi.v

What happens in sd_spi.v (CMD17 sequence):
  1. CS = LOW (select card)
  2. Send 6-byte CMD17 command:
       [0x51][addr[31:24]][addr[23:16]][addr[15:8]][addr[7:0]][0xFF]
       0x51 = CMD17 opcode (READ SINGLE BLOCK)
  3. Wait for R1 response (0x00 = OK)
  4. Wait for data start token: 0xFE
  5. Read 512 bytes:
       Each byte is clocked out and sent to top.v via rd_data + rd_valid
  6. Read 2 CRC bytes (discarded)
  7. CS = HIGH, rd_done = 1

Back in top.v:
  8. Captures ONLY the first byte: first_byte = rd_data (when rd_valid=1)
  9. Extracts lower nibble: disp_digit = first_byte[3:0]
     e.g. 0x35 → lower nibble = 0x5 → digit 5
 10. Shows digit on 7-segment display
 11. read_led <= 1  →  LED[2] turns ON


━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
8. WHAT IS ACTUALLY STORED IN DATA.BIN
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

DATA.BIN is 1MB = 2048 blocks of 512 bytes each.
Think of it like an array of 2048 slots:

  DATA.BIN[0]    = 512 bytes  ← written when SW[15:5]=0
  DATA.BIN[1]    = 512 bytes  ← written when SW[15:5]=1
  DATA.BIN[2]    = 512 bytes  ← written when SW[15:5]=2
  ...
  DATA.BIN[2047] = 512 bytes  ← written when SW[15:5]=2047

Each slot stores 512 copies of the same byte (the digit you wrote).

Example — if you wrote digit '2' at address 1:
  DATA.BIN byte offset 512 to 1023:
  32 32 32 32 32 32 ... 32  (512 times)
  (0x32 = ASCII '2')

When reading, only the FIRST byte of the slot is used.
Lower nibble of that byte = digit shown on 7-seg.


━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
9. VIEWING DATA ON PC
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

Use HxD in DISK MODE (not file mode):
  HxD → Extras → Open Disk → USB Drive (D:) → OK

Offset formula:
  HxD offset (hex) = (20 + SW[15:5]) × 512  →  convert to hex

  SW[15:5]=0  → offset 0x2800
  SW[15:5]=1  → offset 0x2A00
  SW[15:5]=2  → offset 0x2C00
  SW[15:5]=3  → offset 0x2E00

Or use verify_sd.py to read from CMD:
  python C:\AllData\FYPnew\sdreader\verify_sd.py


━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
10. SWITCH SUMMARY
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  SW0        = Mode         1=WRITE  /  0=READ
  SW[4:1]    = Digit        SW4(MSB) SW3 SW2 SW1(LSB) → BCD digit 0-9
  SW[15:5]   = Address      SW15(MSB) ... SW5(LSB) → block 0-2047

  BTNC       = Trigger      Start read or write
  BTND       = Reset        Restart FPGA and reinitialize SD

  LED[0]     = Init OK      SD card ready
  LED[1]     = Write done   Last write completed
  LED[2]     = Read done    Last read completed
  LED[3]     = Busy         Operation in progress
  LED[15]    = Error        SD init or operation failed


━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
11. FILE LIST
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  top.v          Main FPGA logic (switches, buttons, FSM, address)
  sd_spi.v       SPI SD card controller (CMD0/8/55/ACMD41/CMD17/CMD24)
  debounce.v     Button debouncer (removes mechanical bounce noise)
  sevenSeg.v     7-segment display multiplexer
  nexys4ddr.xdc  Pin constraints (Verilog port → FPGA physical pin)
  format_sd.py   One-time PC script: writes FAT16 structure to SD card
  verify_sd.py   PC diagnostic: reads back SD card and prints contents
  HOW_IT_WORKS.txt  This file

================================================================
